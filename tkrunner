#! /usr/bin/env wish
#
# Copyright (c) 2020 Peter Piwowarski <peterjpiwowarski@gmail.com>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

package require Tk 8.6

set cmd {}
set history {}
# Relative to the end; an hpointer of 1 corresponds to a list index of end-1.
# Note that [lindex /foo/ end--1] is the empty string.
set hpointer -1

interp create runner
interp eval runner {
	package require trun

	namespace path [concat [namespace path] ::tcl::mathop ::tcl::mathfunc ::trun]
	namespace unknown ::trun::unknown

	set hide_delay 2000

	trace add execution trun::unknown leave {apply { {cmd code result op} {
		if {!$code} {
			after 2000 hide
		}
	}}}
}
interp alias runner hide {} hide

# apply padding to a list of grid-ed widgets
proc pad_grid_widgets {widgets {amt 1}} {
	set amt [expr {ceil($amt * [tk scaling])}]
	foreach widget $widgets {
		grid configure $widget -padx $amt -pady $amt
	}
}

# define (if necessary) and show the "Run Command" toplevel
proc show {} {
	if {[winfo exists .tkrunner]} {
		wm deiconify .tkrunner
		focus -force .tkrunner
	} else {
		set ::cmd {}

		toplevel .tkrunner
		wm title .tkrunner "Run Command"

		ttk::frame .tkrunner.f
		ttk::entry .tkrunner.f.cmdline -textvariable ::cmd
		ttk::button .tkrunner.f.run -text Run -width 0 -command {
			if {$::history ne ""} {
				.tkrunner.f.msg ins end \n
			}

			lappend ::history $::cmd

			.tkrunner.f.msg ins end "[llength $::history]: [try {
				interp eval runner $cmd
			} on error {err opts} {
				expr {"error: $err"}
			}]" history_line
			.tkrunner.f.msg see end

			set ::hpointer -1
			set ::cmd {}
		}
		text .tkrunner.f.msg -width 80 -height 4 -wrap char \
			-yscrollcommand { .tkrunner.f.scr set }
		.tkrunner.f.msg tag configure history_line \
			-lmargin2 [expr {[tk scaling] * 8}]
		# raw read-only wrapper inspired by the example at
		# https://wiki.tcl-lang.org/page/Read%2Donly+text+widget
		rename .tkrunner.f.msg @internal.tkrunner.f.msg
		proc .tkrunner.f.msg {args} {
			switch -- [lindex $args 0] {
				insert {}
				delete {}
				replace {}
				ins {
					return [@internal.tkrunner.f.msg insert {*}[lrange $args 1 end]]
				}
				default {
					return [@internal.tkrunner.f.msg {*}$args]
				}
			}
		}

		ttk::scrollbar .tkrunner.f.scr -orient vertical -command {
			.tkrunner.f.msg yview
		}

		grid .tkrunner.f.cmdline .tkrunner.f.run -               -sticky ew
		grid .tkrunner.f.msg     -               .tkrunner.f.scr -sticky nsew

		grid columnconfigure .tkrunner.f 0 -weight 1
		grid rowconfigure .tkrunner.f 1 -weight 1
		pad_grid_widgets [winfo children .tkrunner.f]

		pack .tkrunner.f -expand y -fill both

		wm attributes .tkrunner -topmost yes
		focus .tkrunner.f.cmdline

		bind .tkrunner.f.cmdline <KeyPress-Up> {
			if {$::hpointer < ([llength $::history] - 1)} {
				incr ::hpointer
			}
			set ::cmd [lindex $::history end-$::hpointer]
		}
		bind .tkrunner.f.cmdline <KeyPress-Down> {
			if {$::hpointer >= 0} {
				set ::cmd [lindex $::history end-[incr ::hpointer -1]]
			} else {
				set ::cmd {}
			}
		}
		bind .tkrunner <KeyPress-Return> { .tkrunner.f.run invoke }
		bind .tkrunner <KeyPress-Escape> { hide }
		wm protocol .tkrunner WM_DELETE_WINDOW { hide }
	}
}

# hide the "Run Command" toplevel
proc hide {} { wm withdraw .tkrunner }

if {[tk appname tkrunner] ne "tkrunner"} {
	# Tell the already-running tkrunner instance to show its "Run Command"
	# toplevel.
	send tkrunner show
	exit
} else {
	wm withdraw .

	set quiet no

	foreach arg $argv {
		switch -- $arg {
			-quiet { set quiet yes }
			default {
				puts "error: unknown option $arg"
				exit
			}
		}
	}

	if {!$quiet} {
		show
	}
}
